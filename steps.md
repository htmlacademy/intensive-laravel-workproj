# Пошаговая инструкция по разработке с комментариями

## Установка проекта 

https://laravel.com/docs/8.x/installation

Выбираем команду в зависимости от используемой платформы и варианта запуска (через docker или напрямую на хостовой машине).

## Конфигурация 

https://laravel.com/docs/8.x/installation#initial-configuration

- Указать используемую локаль в config/app.php
- Рекомендую задать переменную debug_blacklist и перечислить значения которые не должны выводиться в отладочной информации
- Рекомендую добавить файлы локализации, например из репозитория https://github.com/Laravel-Lang/lang

## Создаем сущности (модели) и миграции

https://laravel.com/docs/8.x/eloquent#generating-model-classes  

Для создания модели с соответсвующей миграцией можно исопльзовать команду `php artisan make:model ModelName --migration`  
Но лучше сразу `php artisan make:model ModelName -cfm --api`, кроме модели и миграции, 
так же будет создана фабрика (для генерации фейковых данных), и api контроллер

Заполняем созданную миграцию: https://laravel.com/docs/8.x/migrations

- Рекомендую использовать timestampTz и timestampsTz поля (для баз данных поддерживающих хранение времени с таймзоной)
- Для создания связанного поля, используем методы `foreignIdFor(Show::class)->constrained();` 
что равнозначно последовательному вызову методов: `foreign('show_id')->references('id')->on('shows')->index();`
- Таблицы для хранения связей ManyToMany именуются с использованием имен таблиц исходных сущностей, 
в единственном числе, в алфавитном порядке. Например, для связи таблиц `shows` и `genres` создается таблица `genre_show`.

- Данные связей которые должны возвращаться всегда при получении моделей, можно указать в свойстве `with` модели.
- Для вывода в модели дополнительных атрибутов используем accessor https://laravel.com/docs/8.x/eloquent-mutators#accessors-and-mutators
- Для приведения типов возвращаемых данных casting https://laravel.com/docs/8.x/eloquent-mutators#attribute-casting
- Если вы будете использовать sqlite движок БД для запуска тестов, в моделях придется указать casts для int полей указывающих на связанную сущность
- Массивы $hidden и $visible позволяют управлять отображаемыми атрибутами, которые мы отдаем "наружу" https://laravel.com/docs/8.x/eloquent-serialization#hiding-attributes-from-json
- Даты created_at и updated_at устанавливаются автоматически при создании и обновлении сущностей. Это поведение можно отключить установив переменную $timestamps = false (что бы выключить обновление обоих полей), или одну из констант CREATED_AT/UPDATED_AT для индивидуального выключения.  
- Описываем связи моделей https://laravel.com/docs/8.x/eloquent-relationships

## Создаем сиды для заполнения БД фейковыми данными

Рекомендую использовать фабрики в качестве источника данных: https://laravel.com/docs/8.x/seeding#using-model-factories  

## Выводим необходимые данные

В созданных вместе с моделью контроллерах, или создаем новые ` php artisan make:controller EntityController --model=Entity`.

Получаем модель сущности используя Route Model Binding https://laravel.com/docs/8.x/routing#route-model-binding

## Добавляем аутентификацию и авторизацию

### Добавляем пакет sanctum

Выполняем базовую настройку по инструкции https://laravel.com/docs/8.x/sanctum (миграции, middlware, trait)

Добавляем методы регистрации и аутентификации.  
Эти методы должны возвращать токен авторизации после успешного выполнения процедур регистрации или входа.  
Этот токен следует отправлять как заголовок аутентификации для обращения на закрытые разделы.  
Закрываем нужные разделы мидлварью `auth:sanctum`

### Добавляем методы регистрации и аутентификации

Используем FormRequest для валидации получаемых данных.  
Используем метод `$request->validated()` для сохранения модели, 
передавая только провалидированные данные, исключив посторнние значения.  

Возвращаем auth token в методах register и login.

Используем полученный токен в методах закрытых мидлварью `auth:sanctum`.

### Добавляем логику 

Используем FormRequest для валидации получаемых данных.  
Используем Route Model Binding https://laravel.com/docs/8.x/routing#route-model-binding для получения данных в контроллере.  

Используем классы обертки для возвращения ответов в едином формате (`App\Http\Responses`).  
Для возвращения ответа из контроллера используем вспомогательные методы объявленные в базовом контроллере (`\App\Http\Controllers\Controller`).  
Оборачиваем ответ с ошибками в ExceptionHandler (`\App\Exceptions\Handler`).  

### Работа с очередями
https://laravel.com/docs/8.x/queues

Создаем Job которая будет выполняться в фоне `sail artisan make:job AddShow`

Настраиваем драйвер очередей, указав выбранный тип запуска `QUEUE_CONNECTION=sync/database/redis`.

Лучше использовать redis, с phpredis расширением php.  
Если возможности использовать расширение нет - можно использовать composer пакет `predis/predis ~1.0`,
указав соответствующее значение в переменной `REDIS_CLIENT=predis`.

Но для наглядности студентам на время разработки проекта рекомендую использовать БД драйвер, 
для отслеживания наличия и состояния задач в очереди.  

Для этого нужно выполнить команду, которая создаст миграцию таблицы задач в БД `php artisan queue:table` 
и `php artisan migrate` применения ее.

При этом для возможности ручной отладки, следует использовать `sync` подключение, для запуска задач не в фоне.

Запуск менеджера очередей выполняется командой `php artisan queue:listen`

### Связывание абстракции и реализации

https://laravel.com/docs/8.x/providers#the-register-method  
https://laravel.com/docs/8.x/container#binding

В зависимости от типа связываемого класса, необходимо использовать методы bind или singleton.  
Также, если нам нужно привязать к интерфейсу настроенный инициированный класс - можно использовать метод instance.

Кроме того можно настроить условия связывания, что бы в разных ситуациях подставлять разные реализации.

### Тестирование классов работающих с внешними сервисами 

https://laravel.com/docs/8.x/testing

При тестировании кода выполняющего запросы к внешним сервисам - необходимо исключить такие запросы, 
заменить их на использование mock реализаций или подмену ответов фикстурами.

https://laravel.com/docs/8.x/mocking

Тесты должны выполняться, при отсутствии интернета, и не зависеть от работы внешних сервисов. 

При тестировании логики работы с БД данные должны создаваться для каждого кейса отдельно, и очищаться после выполнения. 

Этого можно добиться используя трейт RefreshDatabase (для применения и отката миграций перед каждым тест сценарием) 
или с помощью трейта DatabaseTransactions для выполнения сценариев в транзакции (требует применения миграций перед запуском тестов).

https://laravel.com/docs/8.x/database-testing

Все тесты сценарии должны выполняться изолировано друг от друга, и одинаково работать как самостоятельно, 
так и при полном запуске всех сценариев. Для этого в конфиге phpunit должен быть указан параметр `processIsolation="true"`.

Для выполнения http/json запросов в тестах следует использовать соответствующие методы https://laravel.com/docs/8.x/http-tests
Результат можно проверять с помощью методов хелперов на возвращенном объекте ответа.

При создании тестов нужно руководствоваться принципом разумности. Не следует тестировать методы фреймворка, 
и код полностью основывающийся на них. Тестировать нужно свою бизнес логику.  
Особенно нужно хорошо продумывать тестовые сценарии использующие БД, 
т.к. инициализация и обновление состояния БД - это дополнительные ресурсы и время на выполнение тестов.  
Например, необязательно тестировать базовую валидацию для всех методов. 
Но стоит проверять ту часть логики которая влияет на работу приложения, 
т.е. создавая такие тесты по сути мы должны не проверять работу самой валидации, 
а то что мы не забыли покрыть проверками какие-то сценарии.
