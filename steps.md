# Пошаговая инструкция по разработке с комментариями

## Установка проекта 

https://laravel.com/docs/8.x/installation

Выбираем команду в зависимости от используемой платформы и варианта запуска (через docker или напрямую на хостовой машине).

## Конфигурация 

https://laravel.com/docs/8.x/installation#initial-configuration

- Указать используемую локаль в config/app.php
- Рекомендую задать переменную debug_blacklist и перечислить значения которые не должны выводиться в отладочной информации
- Рекомендую добавить файлы локализации, например из репозитория https://github.com/Laravel-Lang/lang

## Создаем сущности (модели) и миграции

https://laravel.com/docs/8.x/eloquent#generating-model-classes  

Для создания модели с соответсвующей миграцией можно исопльзовать команду `php artisan make:model ModelName --migration`  
Но лучше сразу `php artisan make:model ModelName -cfm --api`, кроме модели и миграции, 
так же будет создана фабрика (для генерации фейковых данных), и api контроллер

Заполняем созданную миграцию: https://laravel.com/docs/8.x/migrations

- Рекомендую использовать timestampTz и timestampsTz поля (для баз данных поддерживающих хранение времени с таймзоной)
- Для создания связанного поля, используем методы `foreignIdFor(Show::class)->constrained();` 
что равнозначно последовательному вызову методов: `foreign('show_id')->references('id')->on('shows')->index();`
- Таблицы для хранения связей ManyToMany именуются с использованием имен таблиц исходных сущностей, 
в единственном числе, в алфавитном порядке. Например, для связи таблиц `shows` и `genres` создается таблица `genre_show`.

- Данные связей которые должны возвращаться всегда при получении моделей, можно указать в свойстве `with` модели.
- Для вывода в модели дополнительных атрибутов используем accessor https://laravel.com/docs/8.x/eloquent-mutators#accessors-and-mutators
- Для приведения типов возвращаемых данных casting https://laravel.com/docs/8.x/eloquent-mutators#attribute-casting
- Если вы будете использовать sqlite движок БД для запуска тестов, в моделях придется указать casts для int полей указывающих на связанную сущность
- Массивы $hidden и $visible позволяют управлять отображаемыми атрибутами, которые мы отдаем "наружу" https://laravel.com/docs/8.x/eloquent-serialization#hiding-attributes-from-json
- Описываем связи моделей https://laravel.com/docs/8.x/eloquent-relationships

## Создаем сиды для заполнения БД фейковыми данными

Рекомендую использовать фабрики в качестве источника данных: https://laravel.com/docs/8.x/seeding#using-model-factories  

## Выводим необходимые данные

В созданных вместе с моделью контроллерах, или создаем новые ` php artisan make:controller EntityController --model=Entity`.

Получаем модель сущности используя Route Model Binding https://laravel.com/docs/8.x/routing#route-model-binding

## Добавляем аутентификацию и авторизацию

### Добавляем пакет sanctum

Выполняем базовую настройку по инструкции https://laravel.com/docs/8.x/sanctum (миграции, middlware, trait)

Добавляем методы регистрации и аутентификации.  
Эти методы должны возвращать токен авторизации после успешного выполнения процедур регистрации или входа.  
Этот токен следует отправлять как заголовок аутентификации для обращения на закрытые разделы.  
Закрываем нужные разделы мидлварью `auth:sanctum`

### Добавляем методы регистрации и аутентификации

Используем FormRequest для валидации получаемых данных.  
Используем метод `$request->validated()` для сохранения модели, 
передавая только провалидированные данные, исключив посторнние значения.  

Возвращаем auth token в методах register и login.

Используем полученный токен в методах закрытых мидлварью `auth:sanctum`.

### Добавляем логику 

Используем FormRequest для валидации получаемых данных.  
Используем Route Model Binding https://laravel.com/docs/8.x/routing#route-model-binding для получения данных в контроллере.  

Используем классы обертки для возвращения ответов в едином формате (`App\Http\Responses`).  
Для возвращения ответа из контроллера используем вспомогательные методы объявленные в базовом контроллере (`\App\Http\Controllers\Controller`).  
Оборачиваем ответ с ошибками в ExceptionHandler (`\App\Exceptions\Handler`).  

### Работа с очередями
https://laravel.com/docs/8.x/queues

Создаем Job которая будет выполняться в фоне `sail artisan make:job AddShow`

Настраиваем драйвер очередей.

Лучше использовать redis, с phpredis расширением php.  
Если возможности использовать расширение нет - можно использовать composer пакет `predis/predis ~1.0`.

Но для наглядности студентам на время разработки проекта рекомендую использовать БД драйвер, 
для отслеживания наличия и состояния задач в очереди.  

Для этого нужно выполнить команду, которая создаст миграцию таблицы задач в БД `php artisan queue:table` 
и `php artisan migrate` применения ее.

### Связывание абстракции и реализации

https://laravel.com/docs/8.x/providers#the-register-method  
https://laravel.com/docs/8.x/container#binding

В зависимости от типа связываемого класса, необходимо использовать методы bind или singleton.  
Также, если нам нужно привязать к интерфейсу настроенный инициированный класс - можно использовать метод instance.

Кроме того можно настроить условия связывания, что бы в разных ситуациях подставлять разные реализации.
